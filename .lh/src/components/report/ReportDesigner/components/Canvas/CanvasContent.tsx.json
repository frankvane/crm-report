{
    "sourceFile": "src/components/report/ReportDesigner/components/Canvas/CanvasContent.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1747284629043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1747284865859,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,39 +27,29 @@\n   const [, forceUpdate] = useState({}); // 用于强制刷新\r\n   const isGroupDraggingRef = useRef(false);\r\n   const groupDragStart = useRef<{ x: number; y: number } | null>(null);\r\n   const groupDragOrigin = useRef<Record<string, { x: number; y: number }>>({});\r\n-  // 新增：记录当前拖拽偏移量\r\n-  const [groupDragOffset, setGroupDragOffset] = useState<{\r\n-    dx: number;\r\n-    dy: number;\r\n-  } | null>(null);\r\n \r\n   // 拖动中\r\n   const handleGroupDragging = React.useCallback((e: PointerEvent) => {\r\n     if (!isGroupDraggingRef.current || !groupDragStart.current) return;\r\n     const dx = e.clientX - groupDragStart.current.x;\r\n     const dy = e.clientY - groupDragStart.current.y;\r\n-    setGroupDragOffset({ dx, dy }); // 只更新偏移量，不更新 store\r\n-  }, []);\r\n+    // 只更新 UI，不更新 store\r\n+    Object.entries(groupDragOrigin.current).forEach(([id, pos]) => {\r\n+      onMove(id, pos.x + dx, pos.y + dy);\r\n+    });\r\n+  }, [onMove]);\r\n \r\n   // 拖动结束\r\n   const handleGroupPointerUp = React.useCallback(() => {\r\n-    if (!isGroupDraggingRef.current) return;\r\n     isGroupDraggingRef.current = false;\r\n-    // 统一更新所有选中组件的位置\r\n-    if (groupDragOffset && groupDragOrigin.current) {\r\n-      Object.entries(groupDragOrigin.current).forEach(([id, pos]) => {\r\n-        onMove(id, pos.x + groupDragOffset.dx, pos.y + groupDragOffset.dy);\r\n-      });\r\n-    }\r\n-    setGroupDragOffset(null);\r\n     groupDragStart.current = null;\r\n     groupDragOrigin.current = {};\r\n     document.removeEventListener(\"pointermove\", handleGroupDragging);\r\n     document.removeEventListener(\"pointerup\", handleGroupPointerUp);\r\n     forceUpdate({}); // 强制刷新\r\n-  }, [groupDragOffset, onMove, handleGroupDragging]);\r\n+  }, [handleGroupDragging]);\r\n \r\n   // 计算多选包裹框\r\n   let groupBox = null;\r\n   if (selectedIds.length > 1) {\r\n@@ -80,9 +70,8 @@\n       selectedComps.forEach((c) => {\r\n         origin[c.id] = { x: c.x, y: c.y };\r\n       });\r\n       groupDragOrigin.current = origin;\r\n-      setGroupDragOffset({ dx: 0, dy: 0 }); // 初始化偏移量\r\n       document.addEventListener(\"pointermove\", handleGroupDragging);\r\n       document.addEventListener(\"pointerup\", handleGroupPointerUp);\r\n     };\r\n     groupBox = (\r\n@@ -128,8 +117,14 @@\n       </div>\r\n     );\r\n   }\r\n \r\n+  // 新的 handleMouseDown，拖动多选组时不启动框选\r\n+  const handleMouseDownWrapper = (e: React.MouseEvent) => {\r\n+    if (isGroupDraggingRef.current) return;\r\n+    handleMouseDown(e);\r\n+  };\r\n+\r\n   return (\r\n     <div\r\n       style={{\r\n         position: \"absolute\",\r\n@@ -140,9 +135,9 @@\n         userSelect: selectRect ? \"none\" : undefined,\r\n         zIndex: 10,\r\n         background: \"transparent\",\r\n       }}\r\n-      onMouseDown={handleMouseDown}\r\n+      onMouseDown={handleMouseDownWrapper}\r\n     >\r\n       {/* 框选可视化 */}\r\n       {selectRect && (\r\n         <div\r\n@@ -173,31 +168,17 @@\n           zIndex: 20,\r\n         }}\r\n       >\r\n         {components.length === 0 && <div>拖拽左侧组件到此处</div>}\r\n-        {components.map((comp) => {\r\n-          // 如果是多选组拖动中，且该组件被选中，则渲染时加上偏移量\r\n-          let renderX = comp.x;\r\n-          let renderY = comp.y;\r\n-          if (\r\n-            groupDragOffset &&\r\n-            selectedIds.length > 1 &&\r\n-            selectedIds.includes(comp.id) &&\r\n-            groupDragOrigin.current[comp.id]\r\n-          ) {\r\n-            renderX = groupDragOrigin.current[comp.id].x + groupDragOffset.dx;\r\n-            renderY = groupDragOrigin.current[comp.id].y + groupDragOffset.dy;\r\n-          }\r\n-          return (\r\n-            <ComponentItem\r\n-              key={comp.id}\r\n-              comp={{ ...comp, x: renderX, y: renderY }}\r\n-              isSelected={selectedIds.includes(comp.id)}\r\n-              onSelect={() => setSelectedIds([comp.id])}\r\n-              onResize={(w: number, h: number) => onResize(comp.id, w, h)}\r\n-            />\r\n-          );\r\n-        })}\r\n+        {components.map((comp) => (\r\n+          <ComponentItem\r\n+            key={comp.id}\r\n+            comp={comp}\r\n+            isSelected={selectedIds.includes(comp.id)}\r\n+            onSelect={() => setSelectedIds([comp.id])}\r\n+            onResize={(w: number, h: number) => onResize(comp.id, w, h)}\r\n+          />\r\n+        ))}\r\n       </div>\r\n     </div>\r\n   );\r\n };\r\n"
                },
                {
                    "date": 1747285105598,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,10 +120,14 @@\n       </div>\r\n     );\r\n   }\r\n \r\n-  // 新的 handleMouseDown，拖动多选组时不启动框选\r\n+  // 新的 handleMouseDown，拖动多选组时不启动框选，且手柄拖动时不启动框选\r\n   const handleMouseDownWrapper = (e: React.MouseEvent) => {\r\n+    // 如果事件来自手柄，直接 return\r\n+    if ((e.target as HTMLElement).getAttribute('data-drag-handle') === 'true') {\r\n+      return;\r\n+    }\r\n     if (isGroupDraggingRef.current) return;\r\n     handleMouseDown(e);\r\n   };\r\n \r\n"
                }
            ],
            "date": 1747284629043,
            "name": "Commit-0",
            "content": "import React, { useRef, useState } from \"react\";\r\n\r\nimport ComponentItem from \"./ComponentItem\";\r\n\r\ninterface CanvasContentProps {\r\n  components: any[];\r\n  selectedIds: string[];\r\n  setSelectedIds: (ids: string[]) => void;\r\n  isSelecting: boolean;\r\n  selectRect: { x: number; y: number; w: number; h: number } | null;\r\n  handleMouseDown: (e: React.MouseEvent) => void;\r\n  onResize: (id: string, w: number, h: number) => void;\r\n  onMove: (id: string, x: number, y: number) => void;\r\n}\r\n\r\nconst CanvasContent: React.FC<CanvasContentProps> = ({\r\n  components,\r\n  selectedIds,\r\n  setSelectedIds,\r\n  isSelecting,\r\n  selectRect,\r\n  handleMouseDown,\r\n  onResize,\r\n  onMove,\r\n}) => {\r\n  // 多选包裹框拖动状态\r\n  const [, forceUpdate] = useState({}); // 用于强制刷新\r\n  const isGroupDraggingRef = useRef(false);\r\n  const groupDragStart = useRef<{ x: number; y: number } | null>(null);\r\n  const groupDragOrigin = useRef<Record<string, { x: number; y: number }>>({});\r\n  // 新增：记录当前拖拽偏移量\r\n  const [groupDragOffset, setGroupDragOffset] = useState<{ dx: number; dy: number } | null>(null);\r\n\r\n  // 拖动中\r\n  const handleGroupDragging = React.useCallback(\r\n    (e: PointerEvent) => {\r\n      if (!isGroupDraggingRef.current || !groupDragStart.current) return;\r\n      const dx = e.clientX - groupDragStart.current.x;\r\n      const dy = e.clientY - groupDragStart.current.y;\r\n      setGroupDragOffset({ dx, dy }); // 只更新偏移量，不更新 store\r\n    },\r\n    []\r\n  );\r\n\r\n  // 拖动结束\r\n  const handleGroupPointerUp = React.useCallback(() => {\r\n    if (!isGroupDraggingRef.current) return;\r\n    isGroupDraggingRef.current = false;\r\n    // 统一更新所有选中组件的位置\r\n    if (groupDragOffset && groupDragOrigin.current) {\r\n      Object.entries(groupDragOrigin.current).forEach(([id, pos]) => {\r\n        onMove(id, pos.x + groupDragOffset.dx, pos.y + groupDragOffset.dy);\r\n      });\r\n    }\r\n    setGroupDragOffset(null);\r\n    groupDragStart.current = null;\r\n    groupDragOrigin.current = {};\r\n    document.removeEventListener(\"pointermove\", handleGroupDragging);\r\n    document.removeEventListener(\"pointerup\", handleGroupPointerUp);\r\n    forceUpdate({}); // 强制刷新\r\n  }, [groupDragOffset, onMove, handleGroupDragging]);\r\n\r\n  // 计算多选包裹框\r\n  let groupBox = null;\r\n  if (selectedIds.length > 1) {\r\n    const selectedComps = components.filter((c) => selectedIds.includes(c.id));\r\n    const minX = Math.min(...selectedComps.map((c) => c.x));\r\n    const minY = Math.min(...selectedComps.map((c) => c.y));\r\n    const maxX = Math.max(...selectedComps.map((c) => c.x + c.width));\r\n    const maxY = Math.max(...selectedComps.map((c) => c.y + c.height));\r\n    const boxW = maxX - minX;\r\n    const boxH = maxY - minY;\r\n    // 拖动手柄事件\r\n    const handleGroupPointerDown = (e: React.PointerEvent) => {\r\n      e.stopPropagation();\r\n      e.preventDefault();\r\n      isGroupDraggingRef.current = true;\r\n      groupDragStart.current = { x: e.clientX, y: e.clientY };\r\n      const origin: Record<string, { x: number; y: number }> = {};\r\n      selectedComps.forEach((c) => {\r\n        origin[c.id] = { x: c.x, y: c.y };\r\n      });\r\n      groupDragOrigin.current = origin;\r\n      setGroupDragOffset({ dx: 0, dy: 0 }); // 初始化偏移量\r\n      document.addEventListener(\"pointermove\", handleGroupDragging);\r\n      document.addEventListener(\"pointerup\", handleGroupPointerUp);\r\n    };\r\n    groupBox = (\r\n      <div\r\n        style={{\r\n          position: \"absolute\",\r\n          left: minX,\r\n          top: minY,\r\n          width: boxW,\r\n          height: boxH,\r\n          border: \"2px dashed #1976d2\",\r\n          background: \"rgba(25, 118, 210, 0.04)\",\r\n          zIndex: 999,\r\n          pointerEvents: \"auto\",\r\n        }}\r\n      >\r\n        {/* 拖动手柄 */}\r\n        <div\r\n          style={{\r\n            position: \"absolute\",\r\n            right: -14,\r\n            top: -14,\r\n            width: 24,\r\n            height: 24,\r\n            background: \"#e53935\",\r\n            borderRadius: 6,\r\n            color: \"#fff\",\r\n            fontSize: 14,\r\n            display: \"flex\",\r\n            alignItems: \"center\",\r\n            justifyContent: \"center\",\r\n            cursor: \"grab\",\r\n            zIndex: 1000,\r\n            pointerEvents: \"auto\",\r\n            boxShadow: \"0 2px 8px #e5393522\",\r\n            border: \"2px solid #fff\",\r\n          }}\r\n          onPointerDown={handleGroupPointerDown}\r\n          title=\"拖动选中组件组\"\r\n        >\r\n          ≡\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        position: \"absolute\",\r\n        left: 16,\r\n        top: 16,\r\n        width: \"100%\",\r\n        height: \"100%\",\r\n        userSelect: selectRect ? \"none\" : undefined,\r\n        zIndex: 10,\r\n        background: \"transparent\",\r\n      }}\r\n      onMouseDown={handleMouseDown}\r\n    >\r\n      {/* 框选可视化 */}\r\n      {selectRect && (\r\n        <div\r\n          style={{\r\n            position: \"absolute\",\r\n            left: selectRect.x,\r\n            top: selectRect.y,\r\n            width: selectRect.w,\r\n            height: selectRect.h,\r\n            border: \"1.5px dashed #1976d2\",\r\n            background: \"rgba(25, 118, 210, 0.08)\",\r\n            pointerEvents: \"none\",\r\n            zIndex: 1000,\r\n          }}\r\n        />\r\n      )}\r\n      {/* 多选包裹框 */}\r\n      {groupBox}\r\n      {/* 组件容器，pointerEvents受isSelecting控制 */}\r\n      <div\r\n        style={{\r\n          width: \"100%\",\r\n          height: \"100%\",\r\n          position: \"absolute\",\r\n          left: 0,\r\n          top: 0,\r\n          pointerEvents: isSelecting ? \"none\" : \"auto\",\r\n          zIndex: 20,\r\n        }}\r\n      >\r\n        {components.length === 0 && <div>拖拽左侧组件到此处</div>}\r\n        {components.map((comp) => {\r\n          // 如果是多选组拖动中，且该组件被选中，则渲染时加上偏移量\r\n          let renderX = comp.x;\r\n          let renderY = comp.y;\r\n          if (\r\n            groupDragOffset &&\r\n            selectedIds.length > 1 &&\r\n            selectedIds.includes(comp.id) &&\r\n            groupDragOrigin.current[comp.id]\r\n          ) {\r\n            renderX = groupDragOrigin.current[comp.id].x + groupDragOffset.dx;\r\n            renderY = groupDragOrigin.current[comp.id].y + groupDragOffset.dy;\r\n          }\r\n          return (\r\n            <ComponentItem\r\n              key={comp.id}\r\n              comp={{ ...comp, x: renderX, y: renderY }}\r\n              isSelected={selectedIds.includes(comp.id)}\r\n              onSelect={() => setSelectedIds([comp.id])}\r\n              onResize={(w: number, h: number) => onResize(comp.id, w, h)}\r\n            />\r\n          );\r\n        })}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CanvasContent;\r\n"
        }
    ]
}